* Commentary
  Such commentary, wow.

  #+begin_src emacs-lisp :tangle yes
    ;;; Commentary:
    ;; A hacked together Emacs config.
    ;;; Code:
  #+end_src

  See [[Override keymap]].
  
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defvar zack-keys-minor-mode-map (make-keymap) "Override package keys.")
  #+END_SRC
  
* Package archives
  
  I use the Org mode archive, MELPA, Marmalade and GNU ELPA.
  
  #+begin_src emacs-lisp :tangle yes
    (setq package-archives '(("melpa" . "http://melpa.org/packages/")
			     ("org" . "http://orgmode.org/elpa/")
			     ("marmalade" . "http://marmalade-repo.org/packages/")
			     ("gnu" . "https://elpa.gnu.org/packages/")))
    (package-initialize)
  #+end_src
  
* Local files
  
  I sometimes have a file called `local.el' which contains functions which have passwords (ERC), this is not checked into version control for obvious reasons.
  
  #+BEGIN_SRC emacs-lisp :tangle yes
    (if (file-exists-p "~/.local.el")
	(load "~/.local.el"))
  #+END_SRC
  
* =require-package=
  
  A utility function (borrowed from Bling's (https://github.com/bling)) configuration to install a package.
  
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun require-package (package)
      "Install given PACKAGE."
      (unless (package-installed-p package)
        (unless (assoc package package-archive-contents)
          (package-refresh-contents))
        (package-install package)))
  #+END_SRC
  
* List of packages
  
  This (huge) list contains each package I use, at the end each is passed to `require-package' to download and install.
  
  #+BEGIN_SRC emacs-lisp :tangle yes

    (require 'cl)
    ;; Install packages.
    (defvar pkgs '(use-package
                    ace-flyspell ;; ace-jump-mode for flyspell
                    ace-jump-helm-line ;; use `ace-jump' to jump to a line in Helm.
                    ace-window ;; jump to a window using `ace-jump'.
                    ag ;; the silver searcher
                    anzu
                    avy ;; easymotion
                    bbdb
                    bookmark+ ;; improved boomarks
                    boxquote
                    browse-kill-ring ;; menu for the killring
                    calfw ;; calendar
                    cider ;; REPL for Clojure
                    clojure-mode ;; mode for the Clojure language
                    cmake-mode ;; mode for the CMake language
                    coffee-mode ;; mode for the CoffeeScript language
                    company ;; auto completion
                    company-anaconda ;; Python completion for company
                    company-ghc ;; Haskell completion for company
                    company-tern ;; completion for `tern-mode'.
                    ctags ;; ctags integration for Emacs
                    d-mode ;; mode for the D language
                    dired+ ;; extensions for Dired
                    dired-rainbow ;; RAINBOWS
                    dired-toggle-sudo
                    edit-server ;; used by Edit With Emacs
                    editorconfig ;; make sure I conform to style guides
                    ein ;; iPython Notebook for Emacs
                    el-get
                    elixir-mode ;; major mode for Elixir
                    emacs-eclim ;; turn emacs into an even more IDEer thing using eclim!
                    emmet-mode ;; http://emmet.io implementation for Emacs
                    etags-select
                    evil ;; VIM for Emacs
                    evil-anzu
                    evil-args ;; delimited text objects
                    evil-indent-textobject ;; indentation text object for Evil
                    evil-leader ;; VIM's leader key for Emacs
                    evil-matchit ;; `%' extensions in Evil
                    evil-nerd-commenter ;; efficent commenting for Evil
                    evil-numbers
                    evil-visualstar
                    flycheck ;; on the fly syntax checking
                    flycheck-rust ;; flycheck for the Rust language
                    geiser ;; Racket, Chicken and Guile integration (REPLs, auto-completion) for Emacs.
                    ggtags ;; GNU Global
                    ghc
                    ghci-completion ;; GHC integration for company
                    gist ;; GitHub Gist integration for Emacs.
                    git-gutter ;; Git status in left fringe
                    git-timemachine ;; rollback to previous revisions of a buffer
                    gitconfig-mode ;; major mode for `.gitconfig'
                    gitignore-mode ;; major mode for `.gitignore'
                    gnuplot-mode ;; major mode for gnuplot
                    go-mode ;; major mode for go
                    haskell-mode ;; major mode for Haskell
                    helm ;; menus for ALL the things
                    helm-ag ;; integration with Helm and `ag'
                    helm-projectile ;; projectile integration for helm
                    helm-swoop ;; grep-like tool for Helm
                    highlight-numbers ;; rainbowify numbers
                    hy-mode ;; hy mode
                    hydra ;; micro-states!
                    ibuffer-vc ;; ibuffer integration for vc.el
                    indent-guide ;; a "ruler" for indentation
                    io-mode ;; major mode for Io
                    js2-mode ;; major mode for JavaScript
                    julia-mode ;; mode for the Julia language
                    lentic
                    lua-mode ;; mode for the Lua language
                    magit ;; git integration
                    magit-tramp ;; TRAMP integration for Magit
                    markdown-mode ;; mode for the Markdown markup
                    material-theme
                    mediawiki ;; mediawiki client
                    mmm-mode ;; Multiple Major Modes
                    nim-mode ;; major mode for Nim
                    ocodo-svg-modelines
                    org-bullets
                    pinentry
                    persp-mode ;; basically tabs
                    projectile ;; project management
                    projectile-rails
                    purescript-mode
                    puml-mode
                    racket-mode ;; mode for the Racket
                    rainbow-blocks ;; omg more rainbows
                    rainbow-delimiters ;; RAINNNNNNNNNNBOOOOWWZZ
                    rainbow-identifiers ;; rainbows!
                    rinari ;; Rails
                    ruby-mode ;; mode for the Ruby language
                    rust-mode ;; mode for the Rust language
                    scss-mode ;; mode for the Sass language
                    slim-mode ;; mode for the Slim templating language
                    slime ;; REPL for Common Lisp
                    slime-company
                    smart-mode-line ;; a nice mode line
                    surround ;; Delete surrounding characters (`()', `[]', etc.).
                    table ;; tables!
                    tiny
                    todotxt ;; Mode for the todo.txt markup
                    tuareg ;; ocaml
                    ox-twbs                 ;
                    undo-tree ;; vim-like undo tree
                    wanderlust ;; email
                    web-mode ;; mode for web stuff
                    wgrep ;; writable grep
                    wgrep-ag ;; writable grep, but for ag
                    workgroups2 ;; work groups for Emacs
                    ws-butler ;; whitespace removal
                    yaml-mode ;; major mode for YAML
                    yasnippet ;; snippets
                    zenburn-theme ;; Zenburn theme
                    evil-space
                    ))

    (loop for pkg in pkgs do
          (require-package pkg))
#+END_SRC
* use-package  
  use-package (https://github.com/jwiegley/use-package) handles loading of packages, allowing a neatly organized configuration.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'use-package)
  #+END_SRC

* El-get
  
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package el-get
      :config
      (el-get-bundle org-drill
        :type http
        :pkgname "org-drill"
        :description "org-drill"
        :url "https://bitbucket.org/eeeickythump/org-drill/raw/default/org-drill.el")
      (el-get-bundle org-learn
        :type http
        :pkgname "org-learn"
        :description "org-learn"
        :url "http://orgmode.org/w/?p=org-mode.git;a=blob_plain;f=contrib/lisp/org-learn.el"))
    #+END_SRC
* a-mode

  `a-mode' is (if I remember correctly) my first Emacs Lisp function, quite simple really, all it does is act as a wrapper for `auto-mode-alist', shortening the overall use of it from:

  #+BEGIN_SRC emacs-lisp :tangle no
    (add-to-list 'auto-mode-alist "\\.markdown\\" 'markdown-mode)
  #+END_SRC

  to:

  #+BEGIN_SRC emacs-lisp :tangle no
    (a-mode "markdown" "markdown-mode")
  #+END_SRC

  which I prefer

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun a-mode (ext mode)
      "A 'shortcut' for `(add-to-list 'auto-mode-alist [...])`'"
      (add-to-list 'auto-mode-alist
		   (cons
		    (format "\\%s\\'" ext)
		    (intern (concat mode "-mode")))))
  #+END_SRC
* Org

  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'org)
    (define-key global-map (kbd "C-c l") 'org-store-link)
    (define-key global-map (kbd "C-c a") 'org-agenda)
    (setq org-log-done t)
    (setq org-latex-listings 'minted) ;; enable minted
    (setq org-latex-minted-options
	  '(("frame" "lines")
	    ("fontsize" "\\scriptsize")
	    ("linenos" "")))
    (setq org-latex-minted-langs
	  '((conf-space "aconf")
	    (conf-unix "squid")))
    (setq org-directory "~/org") ;; where I store the documents
    (setq org-latex-to-pdf-process
	  '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
	    "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
	    "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (add-to-list 'org-latex-default-packages-alist '("" "minted" t))
    (add-hook 'after-init-hook (lambda () 
				 (define-key evil-normal-state-map (kbd "TAB") 'org-cycle))) ;; readd TAB back to normal mode in EVIL
  #+END_SRC

** Org-capture + Org-protocol

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'org-capture)
     (require 'org-protocol)

     ;;; Org Capture
     ;;;; Thank you random person from StackOverflow
     ;;;; http://stackoverflow.com/questions/23517372/hook-or-advice-when-aborting-org-capture-before-template-selection

     (defadvice org-capture
	 (after make-full-window-frame activate)
       "Advise capture to be the only window when used as a popup"
       (if (equal "emacs-capture" (frame-parameter nil 'name))
	   (delete-other-windows)))

     (defadvice org-capture-finalize
	 (after delete-capture-frame activate)
       "Advise capture-finalize to close the frame"
       (if (equal "emacs-capture" (frame-parameter nil 'name))
	   (delete-frame)))

     ;;; Capture Templates
     ;;;; Add idea, mind-onanism, contacts, movies to download das
     (setq org-capture-templates
	   '(("l" "Temp Links from the interwebs" item
	      (file+headline "links.org" "Temporary Links")
	      "%?\nEntered on %U\n \%i\n %a")))
   #+END_SRC

** Beautiful Org
*** Org-bullets
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package org-bullets
	:config
	(add-hook 'org-mode-hook 'org-bullets-mode))
    #+END_SRC
    
*** Org-beautify theme
    
#+BEGIN_SRC emacs-lisp :tangle yes
(load-theme 'org-beautify t)
    #+END_SRC


** Babel

   Load the Babel languages that I use, and also use nifty embedded highlighting (syntax within syntax).

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-src-fontify-natively t)
     (setq org-src-fontify-natively t)
     (org-babel-do-load-languages
     'org-babel-load-languages
      '((ruby . t)
	(gnuplot . t)
	(org . t)
	(plantuml . t)))
     (setq org-plantuml-jar-path (expand-file-name "~/plantuml.jar"))
   #+END_SRC
* PlantUML

  #+BEGIN_SRC emacs-lisp :tangle yes
    (auto-image-file-mode 1)
    ;; otherwise, when using `auto-revert-mode` the raw text of the image is displayed after reverting
    (add-hook 'image-mode-hook 'auto-revert-mode)
  #+END_SRC

* Flycheck

  Flycheck is the "modern equivalent of flymake", think of it as [[https://github.com/scrooloose/syntastic][Syntastic]] but for Emacs.

  It adds:

  - Markers in the fringe where syntax errors/style errors/warnings occur.
  - Adds an underline exactly where the error occurs. Fantastic when using a spell checker.
    
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package flycheck
      :init
      (setq flycheck-check-syntax-automatically '(save mode-enabled)) ;; check when the file is written, or a new mode is enabled.
      (setq flycheck-highlighting-mode 'symbols)
      (add-hook 'after-init-hook 'global-flycheck-mode) ;; enable flycheck globally
      (setq flycheck-indication-mode 'left-fringe)) ;; indicate syntax errors/warnings in the left-fringe.
  #+END_SRC


** Flyspell

   Spell checking for Flycheck.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'prog-mode-hook  'flyspell-prog-mode)
     (add-hook 'text-mode-hook  'flyspell-mode)
     (setq python-shell-interpreter "python3") ;; I use Python 3
   #+END_SRC

** Load-path inheritance

   This makes sure that when requiring a file that's within my `load-path' when editing Emacs Lisp code that Flycheck uses my load-path instead of an internal one.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default flycheck-emacs-lisp-load-path 'inherit)
   #+END_SRC

* Emmet

  [[http:/emmet.io][Emmet]] is an incredibly useful tool when dealing with HTML, think of it as "super-charged snippets for HTML".

** =turn-on-emmet-mode=

   Tiny function to use instead of =(lambda [...])= to DRY the code.
 
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun turn-on-emmet-mode ()
       (emmet-mode 1))
   #+END_SRC

   For =(web|sgml|css)-mode=, turn on emmet-mode.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package emmet-mode
       :config
       (add-hook 'web-mode-hook 'turn-on-emmet-mode)
       (add-hook 'sgml-mode-hook 'turn-on-emmet-mode)
       (add-hook 'css-mode-hook 'turn-on-emmet-mode))
   #+END_SRC

* ace-jump

  =avy= is like VIM's [[https://github.com/Lokaltog/vim-easymotion][EasyMotion]] but for Emacs.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package avy
      :config
      (define-key global-map (kbd "C-c SPC") 'avy-goto-char))
  #+END_SRC

  # ** Flyspell
   
  #    =ace-flyspell= navigating to incorrect spelling of words using =ace-jump=, I bind it to =C-c .

  #    #+BEGIN_SRC emacs-lisp :tangle yes
  #      (use-package ace-flyspell
  #        :config
  #        (define-key global-map (kbd "C-c .") 'ace-flyspell-jump-word))
  #    #+END_SRC


  # ** Helm
   
  #    =ace-jump-helm-line= allows jumping to a Helm completion entry using =ace-jump=.

  #    #+BEGIN_SRC emacs-lisp :tangle yes
  #      (use-package ace-jump-helm-line
  #        :bind ("C-@" . ace-jump-helm-line)
  #        :config
  #        (setq helm-display-header-line nil)
  #        (set-face-attribute 'helm-source-header nil :height 0.1))
  #    #+END_SRC


  # ** Windows

  #    =ace-window= allows jumping to a window using =ace-jump=

  #    #+BEGIN_SRC emacs-lisp :tangle yes
  #      (use-package ace-window
  #        :config
  #        (define-key global-map (kbd "C-c w") 'ace-window))
  #    #+END_SRC

* Magit
  Magit is fantastic!

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package magit
      :config
      (setq magit-auto-revert-mode nil)
      (setq magit-last-seen-setup-instructions "1.4.0"))
  #+END_SRC

* Auto completion

  =Company= is a fantastic alternative to =auto-complete=.

  The following:

  - Enables it globally.
  - Makes the completion window popup almost instantly.
  - Makes the completion window popup even if I type a single character.
  - Unbinds `C-w` when within the completion window to prevent a conflict with =evil-mode=.
  - Rebind the previously unbound =company-show-location= to =C-u=.
  - And finally makes =company-backends= local.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package company
      :config
      (add-hook 'after-init-hook 'global-company-mode) ;; enable company-mode globally
      (setq company-idle-delay 0.1)
      (setq company-minimum-prefix-length 1)
      (unbind-key (kbd "C-w") company-active-map)
      (define-key company-active-map (kbd "C-u") 'company-show-location)
      (make-variable-buffer-local 'company-backends))
  #+END_SRC

** Anaconda

   Allows for auto-completion with Python and Company.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package company-anaconda
       :config
       (add-hook 'python-mode-hook (lambda ()
                                     (anaconda-mode)
                                     (add-to-list 'company-backends 'company-anaconda))))
   #+END_SRC

** Haskell

   Utilize =ghc= to autocomplete using Company.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package company-ghc
       :config
       (add-hook 'haskell-mode-hook (lambda ()
                                      (add-to-list 'company-backends 'company-ghc)))
       ;; Haskell!
       (autoload 'ghc-init "ghc" nil t))
   #+END_SRC

* edit-server

  The Chrom(e|ium) addon [[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh][Edit with Emacs]] requires this.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package edit-server
      :config
      (when (string= (system-name) "linux-nyit.site") ;; home PC
	(edit-server-start)))
  #+END_SRC

* Anzu

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package anzu
      :config
      (global-anzu-mode 1))
  #+END_SRC

* EVIL

  EVIL is VIM within Emacs.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil
      :config
      (evil-mode 1)
      (evil-define-key 'normal global-map (kbd "}]") 'emmet-next-edit-point)
      (evil-define-key 'normal global-map (kbd "{[") 'emmet-prev-edit-point)
      (evil-define-key 'normal global-map (kbd "U") 'undo-tree-visualize))
  #+END_SRC

** Text-object delimiters

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package surround
       :config
       (global-surround-mode 1))
   #+END_SRC


** NERD-commenter

   VIM's NERD-commenter but for Emacs.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-nerd-commenter
       :config
       (define-key evil-normal-state-map "gci" 'evilnc-comment-or-uncomment-lines)
       (define-key evil-normal-state-map "gcl" 'evilnc-quick-comment-or-uncomment-to-the-line)
       (define-key evil-normal-state-map "gll" 'evilnc-quick-comment-or-uncomment-to-the-line)
       (define-key evil-normal-state-map "gcc" 'evilnc-copy-and-comment-lines)
       (define-key evil-normal-state-map "gcp" 'evilnc-comment-or-uncomment-paragraphs)
       (define-key evil-normal-state-map "gcr" 'comment-or-uncomment-region)
       (define-key evil-normal-state-map "gcv" 'evilnc-toggle-invert-comment-line-by-line))
   #+END_SRC

** Leader

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-leader
       :config
       (evil-leader/set-leader "<SPC>") ;; space is my leader
       (global-evil-leader-mode 1)
       (evil-leader/set-key
	 "p b" 'projectile-switch-to-buffer
	 "p D" 'projectile-dired
	 "p d" 'projectile-find-dir
	 "p s" 'projectile-switch-project
	 "p R" 'projectile-regenerate-tags
	 "p j" 'projectile-find-tag
	 "g t r" 'ctags-create-or-update-tags-table))
   #+END_SRC
** Modeline color changing

   I found this in Bling's dotemacs.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (set-face-background 'mode-line "SaddleBrown")
     (defun my-evil-modeline-change (default-color)
       "changes the modeline color when the evil mode changes"
       (let ((color (cond ((evil-insert-state-p) '("#002233" . "#ffffff"))
                          ((evil-visual-state-p) '("#330022" . "#ffffff"))
                          ((evil-normal-state-p) default-color)
                          (t '("#440000" . "#ffffff")))))
         (set-face-background 'mode-line (car color))
         (set-face-foreground 'mode-line (cdr color))))

     (lexical-let ((default-color (cons (face-background 'mode-line)
                                        (face-foreground 'mode-line))))
       (add-hook 'post-command-hook (lambda () (my-evil-modeline-change default-color))))
   #+END_SRC

** Cursor changing

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq evil-insert-state-cursor '((bar . 2) "white")
           evil-visual-state-cursor '((bar . 5) "white")
           evil-normal-state-cursor '((hollow . 5) "white"))
   #+END_SRC

** Matching

   Extends =%=.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-matchit
       :config
       (global-evil-matchit-mode))
   #+END_SRC

** Space

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-space
       :config
       (unbind-key "C-p" evil-normal-state-map)
       (unbind-key "C-p" global-map)
       (unbind-key "C-]" evil-motion-state-map)
       (unbind-key "C-]" global-map)
       (setq evil-space-next-key (kbd "C-]"))
       (setq evil-space-prev-key (kbd "C-p"))
       (evil-space-mode 1))
   #+END_SRC

* Workgroups

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package workgroups2
      :config
      (workgroups-mode 1))
  #+END_SRC

* persp-mode

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package persp-mode
      :config
      (add-hook 'after-init-hook 'persp-mode)
      (setq persp-use-workgroups t))
  #+END_SRC

* GNU Global

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ggtags
      :config
      (add-hook 'prog-mode-hook 'ggtags-mode)) ;; enable ggtags for all prgoramming-mode
  #+END_SRC

* Git-gutter

  Git-gutter displays a summary of =git diff= in the left fringe of the current buffer.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package git-gutter
      :config
      (global-git-gutter-mode 1))
  #+END_SRC

* Helm
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package helm
      :config
      (helm-mode 1)
      (helm-autoresize-mode 1)
      (global-set-key (kbd "C-x C-f") 'helm-find-files))
  #+END_SRC
** Projectile
   Integrate Projectile and Helm.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package helm-projectile
       :config
       (global-set-key (kbd "C-c h") 'helm-projectile))
   #+END_SRC

** Helm-M-x

   Helm's version of M-x.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (define-key global-map (kbd "M-x") 'helm-M-x)
   #+END_SRC

** Helm-swoop

   Alternative to I-search.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package helm-swoop
       :config
       (define-key global-map (kbd "C-c C-a C-c") 'helm-swoop))
   #+END_SRC

* Languages
** SCSS

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package scss-mode
       :config
       (setq scss-compile-at-save nil)
       (a-mode ".scss" "scss"))

   #+END_SRC

** Common Lisp
*** SLIME
  
    SLIME (Superior Lisp Interaction Mode for Emacs) turns Emacs into an excellent IDE for Common Lisp.

    The following makes sure that I can still use the SLIME REPL history when on-the-go with my physical keyboard and phone.

    `slime-setup' is also loads:

    - slime-fancy: makes SLIME spiffy with history, and other stuff.
    - slime-repl: the core of SLIME
    - slime-company: auto-completion in the REPL when using SLIME.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (require 'slime-autoloads)
      (use-package slime
	:config
	(add-hook 'slime-repl-mode-hook
		  (lambda ()
		    ;; my portable keyboard + VX Connectbot doesn't like M-p and M-n.
		    (evil-define-key 'insert slime-repl-mode-map (kbd "C-p") 'slime-repl-previous-input)
		    (evil-define-key 'insert slime-repl-mode-map (kbd "C-n") 'slime-repl-next-input)
		    (evil-define-key 'normal slime-repl-mode-map (kbd "C-p") 'slime-repl-previous-input)
		    (evil-define-key 'normal slime-repl-mode-map (kbd "C-n") 'slime-repl-next-input)))
	(slime-setup '(slime-fancy slime-repl slime-company))
	(setq inferior-lisp-program "sbcl")) ;; use SBCL
    #+END_SRC


** Clojure
** Haskell

   I don't program in Haskell much, but someday I will.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package haskell-mode
       :config
       (setq haskell-font-lock-symbols t) ;; spiffy symbols.
       (add-hook 'haskell-mode-hook 'ghc-init)
       (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation))
   #+END_SRC


** Cider

   I like Clojure, so CIDER is a must for me.

   The following enables Eldoc for use with CIDER.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package cider
       :config
       (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
       (a-mode ".boot" "clojure")
       (add-to-list 'magic-mode-alist '(". boot" . clojure-mode)))
   #+END_SRC

** JavaScript

   I like JavaScript.

   js2-mode is a great alternative to the standard js-mode.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package js2-mode
       :init
       (a-mode ".js" "js2")
       (add-hook 'js2-mode-hook (lambda ()
				  (tern-mode t) ;; enable auto-completion using ternjs.
				  (add-to-list 'company-backends 'company-tern))))
   #+END_SRC

*** Notes

    - js2-mode works great with ES6
    - ternjs doesn't work at all with ES6, but it is in the works.

** Web

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package web-mode
       :config
       (a-mode ".phtml" "web")
       (a-mode ".tpl\\.php" "web")
       (a-mode ".[agj]sp" "web")
       (a-mode ".as[cp]x" "web")
       (a-mode ".erb" "web")
       (a-mode ".mustache" "web")
       (a-mode ".djhtml" "web")
       (a-mode ".ejs" "web")
       (a-mode ".html?" "web")
       (a-mode ".php" "web"))
   #+END_SRC

** Gitolite

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package gl-conf-mode
       :config
       (add-to-list 'auto-mode-alist '("gitolite\\.conf\\'" .
				       gl-conf-mode)))
   #+END_SRC


** GDScript
   
   Godot's scripting language.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'gdscript-mode)
   #+END_SRC

   Also enable rainbow things for GDScript.


   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'gdscript-mode-hook 'rainbow-identifiers-mode)
     (add-hook 'gdscript-mode-hook 'rainbow-delimiters-mode)
   #+END_SRC

*** TODO [0/1]
    - [ ] Make =gdscript-mode.el= derive from =prog-mode= to obsolete above.
** CMake

   CMake is a great alternative to autotools/automake. I use it for any C/C++ project I work on.

   The following makes =CMakeLists.txt= use =cmake-mode=.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package cmake-mode
       :init
       (add-to-list 'auto-mode-alist
		    '("CMakeLists.txt" . cmake-mode)) )
   #+END_SRC

** VisualBasic
   
   Used for work experience.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (autoload 'visual-basic-mode "visual-basic-mode" "Visual Basic mode." t)
     (a-mode ".vbs" "visual-basic")
   #+END_SRC

** Scheme

   Geiser is great for scheme.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package geiser
       :config
       (add-hook 'scheme-mode-hook (lambda ()
				     (add-to-list 'company-backends 'geiser-company-backend))))
   #+END_SRC

* ibuffer

  ibuffer is an enhanced version of the standard =buffer-menu=.

** VC

   Integrate ibuffer and vc.el.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ibuffer-vc
       :bind ("C-x C-b" . ibuffer)
       :init
       (require 'ibuffer-vc)
       :config
       (setq ibuffer-formats
	     '((mark modified read-only vc-status-mini " "
		     (name 18 18 :left :elide)
		     " "
		     (size 9 -1 :right)
		     " "
		     (mode 16 16 :left :elide)
		     " "
		     (vc-status 16 16 :left)
		     " "
		     filename-and-process)))
       (add-hook 'ibuffer-hook
		 (lambda ()
		   (ibuffer-vc-set-filter-groups-by-vc-root))))
   #+END_SRC

* indent-guide

  Indent-guide adds a fancy line to indicate the current indentation position.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package indent-guide
      :config
      (indent-guide-global-mode 1)) ;; enable globally
  #+END_SRC

* Multiple-Major-Modes
  This package is *fantastic* for things that embed other languages.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package mmm-mode
      :config
      (setq mmm-global-mode 'maybe)
      (mmm-add-classes
       '((markdown-latex
          :submode latex-mode
          :front "\\\\begin" ;; 2 blackslashes because of basedocument requiring 2 because of macro processing.
          :back "\\\\end")
         (markdown-erb
          :submode ruby-mode
          :front "<%"
          :back "%>")
         (markdown-clojure
          :submode clojure-mode
          :front "```clojure"
          :back "```")
         (markdown-ruby
          :submode ruby-mode
          :front "```ruby"
          :back "```")
         (markdown-haskell
          :submode haskell-mode
          :front "```haskell"
          :back "```")
         (markdown-lisp
          :submode common-lisp-mode
          :front "```commonlisp"
          :back "```")
         (shell-json
          :submode javascript-mode
          :front "<<JSON"
          :back "JSON")))
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-latex)
      (mmm-add-mode-ext-class 'markdown-mode "\\.mderb\\'" 'markdown-erb)
      (mmm-add-mode-ext-class 'shell-mode "\\.sh\\'" 'shell-json)
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-clojure)
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-ruby)
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-lisp)
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-haskell))
    (a-mode ".mderb" "markdown")
  #+END_SRC

* Projectile

  Projectile is great for handling large projects.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package projectile
      :bind ("C-c v f" . helm-projectile-find-file)
      :config
      (setq projectile-completion-system 'helm)
      (projectile-global-mode)
      (add-hook 'projectile-mode-hook 'projectile-rails-on))
  #+END_SRC

* Smart-Mode-Line

  I have yet to get around to making my own mode-line, but Smart-Mode-Line is great, so I don't see why I need to, other than for fun of course.


  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package smart-mode-line
      :config
      (setq sml/theme 'dark)
      (sml/setup))
  #+END_SRC

* Ag

  Ag is a super-fast alternative to grep.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ag
      :config
      (define-key ag-mode-map (kbd "k") nil)) ;; stop conflicts with evil
  #+END_SRC

* ws-butler

  Used to remove whitespace.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ws-butler
      :config
      (add-hook 'prog-mode-hook 'ws-butler-mode))
  #+END_SRC

* YASnippet

  Snippet for Emacs.


  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yasnippet
      :config
      (yas-global-mode 1)
      (a-mode ".snip" "snippet")
      (define-key yas-minor-mode-map (kbd "C-c 7 n") 'yas-next-field)
      (define-key yas-minor-mode-map (kbd "C-c 7 p") 'yas-prev-field)
      (define-key yas-minor-mode-map (kbd "<tab>") nil)
      (define-key yas-minor-mode-map (kbd "TAB") nil)
      (define-key evil-insert-state-map (kbd "C-c RET") 'yas-expand))
  #+END_SRC


  (require 'ctags)
  (setq ctags-command "/usr/bin/ctags-exuberant -e -R ")
  (setq vc-follow-symlinks t)
* Email

  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'mail-mode-hook 'auto-fill-mode) ;; hard-wrap text when emailing
  #+END_SRC

** Wanderlust

   Not used much, but might switch to Wanderlust one day.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'wl)
     (autoload 'wl "wl" "Wanderlust" t)
     (a-mode ".wl" "emacs-lisp")
     (add-to-list 'auto-mode-alist
		  '("mutt-" . mail-mode)) ;; mutt temporary files
     (defun foo-wl ()
       (when evil-mode (evil-change-state 'emacs)))

     (add-hook 'wl-hook 'foo-wl)
     (add-hook 'wl-folder-mode-hook 'foo-wl)
     (add-hook 'wl-summary-mode-hook 'foo-wl)
     (add-hook 'wl-message-mode-hook 'foo-wl)
     (add-hook 'mime-view-mode-hook 'foo-wl)
     (add-hook 'wl-template-mode-hook 'foo-wl)
     (require 'bbdbV3-wl)
   #+END_SRC

* undotree

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package undo-tree
      :config
      (setq undo-tree-auto-save-history 1)
      (setq undo-tree-history-directory-alist (quote (("." . "~/.emacs.d/undo/"))))
      (setq undo-tree-visualizer-diff t))
  #+END_SRC

* Rainbows

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package highlight-numbers
      :config
      (add-hook 'prog-mode-hook 'highlight-numbers-mode))
    (use-package rainbow-identifiers
      :config
      (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
    (use-package rainbow-delimiters
      :config
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode-enable)
      (add-hook 'text-mode-hook 'rainbow-delimiters-mode-enable))
  #+END_SRC

* imenu

  Useful for navigating around my config.


  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package imenu
      :config
      (add-to-list 'imenu-generic-expression
		   '("Used Packages"
		     "\\(^\\s-*(use-package +\\)\\(\\_<.+\\_>\\)" 2))
      (define-key zack-keys-minor-mode-map (kbd "C-d") 'imenu))
  #+END_SRC

* Misc

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq org-export-htmlize-output-type 'css)
    (set-face-attribute 'default nil :height 85)
    (require 'tramp) ;; edit files on remote locations
    (require 'whitespace) ;; whitespace monitor
    (column-number-mode 1) ;; enable column number in modeline
    (menu-bar-mode -1) ;; disabe menubar
    (tool-bar-mode -1) ;; disable toolbar
    (when (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1)) ;; disable scrollbar
    (electric-pair-mode 1) ;; match parens automatically
    (setq-default indent-tabs-mode nil) ;; no tabs.
    (setq-default tab-width 2) ;; Ruby-style indentation
    (require 'saveplace)
    (setq-default save-place t)
    (a-mode ".md" "markdown")
    (a-mode ".markdown" "markdown")
    (a-mode ".mdwn" "markdown")
    (a-mode ".mw" "mediawiki")
    (a-mode "Gemfile" "ruby")
    (a-mode "Guardfile" "ruby")
    (a-mode "Rakefile" "ruby")
    (require 'htmlize)
    (electric-indent-mode 1) ;; automatically indent on RET or others
    (show-paren-mode 1) ;; highlight matching parens
    (mouse-avoidance-mode 'banish) ;; be gone cursor!
    (setq initial-scratch-message ;; I know it's a scratch buffer by now!
	  (format ";; Emacs was started at %s"
		  (format-time-string "%Y-%m-%dT%T")))
    (setq package-menu-async nil) ;; disable this, I hate it when I press "U" just when I run `list-packages' to result in it claiming there's no updates avaialble so I have to run it again.
  #+END_SRC

** Backups

   I don't commit on every change I make, that'd be silly, so put numbered backups in here to not pollute commit history.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
     (setq delete-old-versions -1)
     (setq version-control t)
     (setq vc-make-backup-files t)
     (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
   #+END_SRC

* Utility functions

* Sort sexps

  From Sacha Chua.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun sort-sexps-in-region (beg end)
      "Can be handy for sorting out duplicates.
      Sorts the sexps from BEG to END. Leaves the point at where it
      couldn't figure things out (ex: syntax errors)."
      (interactive "r")
      (let ((input (buffer-substring beg end))
	    list last-point form result)
	(save-restriction
	  (save-excursion
	    (narrow-to-region beg end)
	    (goto-char (point-min))
	    (setq last-point (point-min))
	    (setq form t)
	    (while (and form (not (eobp)))
	      (setq form (ignore-errors (read (current-buffer))))
	      (when form
		(add-to-list 'list
			     (cons
			      (prin1-to-string form)
			      (buffer-substring last-point (point))))
		(setq last-point (point))))
	    (setq list (sort list (lambda (a b) (string< (car a) (car b)))))
	    (delete-region (point-min) (point))
	    (insert (mapconcat 'cdr list "\n"))))))
  #+END_SRC
** Get a random item from a list

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun get-rnd-list (lst)
       "Get a random item from a list."
       (nth (random* (length lst)) lst))
   #+END_SRC

** Get a random color

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun random-color ()
       "Get a random color."
       (get-rnd-list '("blue" "red" "yellow" "pink")))
   #+END_SRC
*** TODO [0/1]
    - [ ] Add more colors

** Increment the number at point, like VIM's =C-a=

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun increment-number-at-point ()
       (interactive)
       (skip-chars-backward "0123456789")
       (or (looking-at "[0123456789]+")
	   (error "No number at point"))
       (replace-match (number-to-string (1+ (string-to-number (match-string 0))))))
     (global-set-key (kbd "C-c +") 'increment-number-at-point)
   #+END_SRC

** Decrement the number at point, like VIM's =C-x=

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun decrement-number-at-point ()
       (interactive)
       (skip-chars-backward "0123456789")
       (or (looking-at "[0123456789]+")
	   (error "No number at point"))
       (replace-match (number-to-string (1- (string-to-number (match-string 0))))))

     (global-set-key (kbd "C-c -") 'decrement-number-at-point)

   #+END_SRC

* Boxquote
  
  From https://github.com/joedicastro/dotfiles/tree/master/emacs

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package boxquote
      :config
      (setq-default  boxquote-bottom-corner "╰"       ; U+2570
		     boxquote-side          "│ "      ; U+2572 + space
		     boxquote-top-and-tail  "────"    ; U+2500 (×4)
		     boxquote-top-corner    "╭"))     ; U+256F
  #+END_SRC

* Insert shell command

  Insert the output of a shell command into the buffer at cursor's position.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun insert-shell-command (command)
      (interactive "scommand: ")
      (insert (shell-command-to-string command)))

    (define-key global-map (kbd "C-c C-g") 'insert-shell-command)
  #+END_SRC

* History

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq list-command-history-max 500) ;; save an insane amount of previously-used commands
    (setq savehist-file "~/.emacs.d/savehist")
    (savehist-mode 1)
    (setq history-length t)
    (setq history-delete-duplicates t)
    (setq savehist-save-minibuffer-history 1)
    (setq savehist-additional-variables
	  '(kill-ring
	    search-ring
	    regexp-search-ring))
  #+END_SRC

* Eldoc

  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'python-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  #+END_SRC
  
* Extra-warning face

  Used to make things stand out even more then =font-lock-warning-face=.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defface extra-warning-face
      '((t :background "red"
	   :foreground "brightblue"))
      "Face for even more warninger warnings."
      :group 'basic-faces)

    (defvar keywords '(("\\b\\(BUG\\)\\b" 1 'extra-warning-face))
      "List of keywords to highlight in extra-warning-face.")

    (add-hook 'prog-mode-hook (lambda () (font-lock-add-keywords nil keywords)))
    (add-hook 'text-mode-hook (lambda () (font-lock-add-keywords nil keywords)))
  #+END_SRC

* Misc utilities

  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'calendar)
    (defun insdate-insert-current-date (&optional omit-day-of-week-p)
      "Insert today's date using the current locale.
    With a prefix argument, the date is inserted without the day of
    the week."
      (interactive "P*")
      (insert (calendar-date-string (calendar-current-date) nil
				    omit-day-of-week-p)))
  #+END_SRC

* Override keymap

  Idea from http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs

  This is used to override package keymaps (who put there mappings in =C-c=!) without going through the process of:

  1. =C-h k= to see if the binding is used.
  2. Look at =C-h k= to find the keymap it uses.
  3. Unbind the key from the keymap.
  4. Repeat 1 to 3 if packages actually use the same keymapping and they overlap.
  5. Bind your key.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (define-minor-mode zack-keys-minor-mode
      "Override package keys."
      t " z-keys" 'zack-keys-minor-mode-map)
  #+END_SRC

* Tiny

  [[https://github.com/abo-abo/tiny][Tiny]] is an alternative to macros, using a tiny template language.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package tiny
      :config
      (tiny-setup-default))
  #+END_SRC

* Pinentry

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package pinentry
      :config
      (setenv "INSIDE_EMACS" "1"))
  #+END_SRC
* Pretty symbols
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq prettify-symbols-alist '(("!=" "≠")
				   ("! " "¬ ")))
  #+END_SRC

* Pretty markdown

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'markdown-mode-hook (lambda ()
(set-face-attribute 'markdown-header-face-1 nil :weight 'bold :height 250)
(set-face-attribute 'markdown-header-face-2 nil :weight 'bold :height 200)
(set-face-attribute 'markdown-header-face-3 nil :weight 'bold :height 150)
(set-face-attribute 'markdown-header-face-4 nil :weight 'bold :height 100)
(set-face-attribute 'markdown-header-face-5 nil :weight 'bold :height 50)
(set-face-attribute 'markdown-header-face-6 nil :weight 'bold :height 25)))
#+END_SRC

* Hydras


#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra window-resize (:color blue)

"
Resizing
========

_h_: left      _k_: up
_l_: right     _j_: down"

("h" shrink-window-horizontally)
("k" shrink-window-horizontally)
("l" shrink-window-horizontally)
("j" shrink-window-horizontally)
)


#+END_SRC

* Font  

#+BEGIN_SRC emacs-lisp :tangle yes
(set-face-attribute 'default t :font "Hack-8")
#+END_SRC

* The end

  #+BEGIN_SRC emacs-lisp :tangle yes
    (provide 'init) ;; that's a wrap folks!
    ;;; init.el ends here
  #+END_SRC

* Cascade startup system
  
** =waitforemacs=

   Hangs until a certain other Emacs server starts.

   #+INCLUDE: "~/bin/waitforemacs" src shell

** =emacsinotify=

   #+INCLUDE: "~/bin/emacsinotify" src shell
