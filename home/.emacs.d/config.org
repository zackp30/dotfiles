* Commentary
  Such commentary, wow.

  #+BEGIN_SRC emacs-lisp :tangle yes
    ;;; Commentary:
    ;; A hacked together Emacs config.
    ;;; Code:
  #+END_SRC

  See [[Override keymap]].

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defvar zack-keys-minor-mode-map (make-keymap) "Override package keys.")
  #+END_SRC

* Package archives

  I use the Org mode archive, MELPA, Marmalade and GNU ELPA.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq package-archives `(("melpa" . ,melpa-url)
                             ("org" . "http://orgmode.org/elpa/")
                             ("marmalade" . "https://marmalade-repo.org/packages/")
                             ("gnu" . "https://elpa.gnu.org/packages/")))
    (package-initialize)
    (package-refresh-contents)
  #+END_SRC

* Local files

  I sometimes have a file called `local.el' which contains functions
  which have passwords (ERC), this is not checked into version control
  for obvious reasons.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (when (file-exists-p "~/.local.el")
        (load "~/.local.el"))
  #+END_SRC

* List of packages

  This (huge) list contains each package I use, at the end each is
  passed to `require-package' to download and install.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'cl)
    ;; Install packages.
    (defvar pkgs '(use-package
                    ace-flyspell ;; ace-jump-mode for flyspell
                    ace-jump-helm-line ;; use `ace-jump' to jump to a line in Helm.
                    ace-window ;; jump to a window using `ace-jump'.
                    ag ;; the silver searcher
                    anzu
                    avy ;; easymotion
                    bbdb
                    beacon
                    bookmark+ ;; improved boomarks
                    boxquote
                    bpr
                    browse-kill-ring ;; menu for the killring
                    calfw ;; calendar
                    cider ;; REPL for Clojure
                    clojure-mode ;; mode for the Clojure language
                    cmake-mode ;; mode for the CMake language
                    coffee-mode ;; mode for the CoffeeScript language
                    company ;; auto completion
                    company-anaconda ;; Python completion for company
                    company-ghc ;; Haskell completion for company
                    company-tern ;; completion for `tern-mode'.
                    ctags ;; ctags integration for Emacs
                    d-mode ;; mode for the D language
                    dired+ ;; extensions for Dired
                    dired-rainbow ;; RAINBOWS
                    dired-subtree
                    dired-toggle-sudo
                    edit-server ;; used by Edit With Emacs
                    editorconfig ;; make sure I conform to style guides
                    ein ;; iPython Notebook for Emacs
                    el-get
                    elfeed
                    elixir-mode ;; major mode for Elixir
                    emacs-eclim ;; turn emacs into an even more IDEer thing using eclim!
                    emmet-mode ;; http://emmet.io implementation for Emacs
                    emojify ;; emojis :smile:
                    etags-select
                    evil ;; VIM for Emacs
                    evil-anzu
                    evil-args ;; delimited text objects
                    evil-indent-textobject ;; indentation text object for Evil
                    evil-leader ;; VIM's leader key for Emacs
                    evil-matchit ;; `%' extensions in Evil
                    evil-nerd-commenter ;; efficent commenting for Evil
                    evil-numbers
                    evil-space
                    evil-textobj-anyblock
                    evil-visualstar
                    flycheck ;; on the fly syntax checking
                    flycheck-pos-tip
                    flycheck-rust ;; flycheck for the Rust language
                    fountain-mode
                    geiser ;; Racket, Chicken and Guile integration (REPLs, auto-completion) for Emacs.
                    ghc
                    ghci-completion ;; GHC integration for company
                    gist ;; GitHub Gist integration for Emacs.
                    git-gutter ;; Git status in left fringe
                    git-timemachine ;; rollback to previous revisions of a buffer
                    gitconfig-mode ;; major mode for `.gitconfig'
                    gitignore-mode ;; major mode for `.gitignore'
                    gnuplot
                    gnuplot-mode ;; major mode for gnuplot
                    go-mode ;; major mode for go
                    graphviz-dot-mode
                    haskell-mode ;; major mode for Haskell
                    helm ;; menus for ALL the things
                    helm-ag ;; integration with Helm and `ag'
                    helm-projectile ;; projectile integration for helm
                    helm-swoop ;; grep-like tool for Helm
                    highlight-indentation
                    highlight-numbers ;; rainbowify numbers
                    hy-mode ;; hy mode
                    hydra ;; micro-states!
                    ibuffer-vc ;; ibuffer integration for vc.el
                    indent-guide ;; a "ruler" for indentation
                    io-mode ;; major mode for Io
                    js2-mode ;; major mode for JavaScript
                    julia-mode ;; mode for the Julia language
                    lentic
                    lua-mode ;; mode for the Lua language
                    magit ;; git integration
                    magit-tramp ;; TRAMP integration for Magit
                    markdown-mode ;; mode for the Markdown markup
                    material-theme
                    mmm-mode ;; Multiple Major Modes
                    mode-icons ;; icons for major modes
                    nim-mode ;; major mode for Nim
                    ob-ipython
                    org-bullets
                    org-ref
                    pinentry
                    projectile ;; project management
                    puml-mode
                    purescript-mode
                    racket-mode ;; mode for the Racket
                    rainbow-blocks ;; omg more rainbows
                    rainbow-delimiters ;; RAINNNNNNNNNNBOOOOWWZZ
                    rainbow-identifiers ;; rainbows!
                    realgud
                    rinari ;; Rails
                    ruby-mode ;; mode for the Ruby language
                    rust-mode ;; mode for the Rust language
                    scss-mode ;; mode for the Sass language
                    slim-mode ;; mode for the Slim templating language
                    slime ;; REPL for Common Lisp
                    slime-company
                    smart-mode-line ;; a nice mode line
                    stumpwm-mode
                    surround ;; Delete surrounding characters (`()', `[]', etc.).
                    table ;; tables!
                    tiny
                    todotxt ;; Mode for the todo.txt markup
                    tuareg ;; ocaml
                    typo ;; typographic quotes
                    undo-tree ;; vim-like undo tree
                    wanderlust ;; email
                    web-mode ;; mode for web stuff
                    wgrep ;; writable grep
                    wgrep-ag ;; writable grep, but for ag
                    which-key
                    ws-butler ;; whitespace removal
                    yaml-mode ;; major mode for YAML
                    yasnippet ;; snippets
                    zenburn-theme) ;; Zenburn theme
      "List of packages.")

    (loop for pkg in pkgs do
          (require-package pkg))
#+END_SRC

* use-package
  use-package (https://github.com/jwiegley/use-package) handles
  loading of packages, allowing a neatly organized configuration.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'use-package)
  #+END_SRC

* Utilities
** =rebind-key=

#+BEGIN_SRC emacs-lisp :tangle yes
    (defun rebind-key (from-key map to-key)
      (define-key map from-key nil)
      (define-key map to-key (lookup-key map from-key)))
#+END_SRC

** =scase=

   Like =case= but for string equality, not using =eq=.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defmacro scase (to-compare &rest forms)
       `(cond
         ,@(mapcar (lambda (form)
                     `((string= ,(first form) ,to-compare)
                       ,(second form)))
                   forms)))
   #+END_SRC

* El-get

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package el-get
      :config
      (el-get-bundle org-drill
        :type http
        :pkgname "org-drill"
        :description "org-drill"
        :url "https://bitbucket.org/eeeickythump/org-drill/raw/default/org-drill.el")
      (el-get-bundle alphapapa/org-protocol-capture-html)
      (el-get-bundle github:zackp30/ox-twbs)
      (el-get-bundle org-reveal
        :type github
        :pkgname "yjwen/org-reveal"
        :description "Exports Org-mode contents to Reveal.js HTML presentation."
        :depends org-mode
        :features ox-reveal)
      (el-get-bundle helm-bbdb
        :type http
        :pkgname "helm-bbdb"
        :description "helm-bbdb"
        :url "https://raw.githubusercontent.com/emacs-helm/helm-bbdb/master/helm-bbdb.el")
      ;; From https://raw.githubusercontent.com/dimitri/el-get/master/recipes/ntcmd.rcp
      (el-get-bundle ntcmd
        :type emacswiki
        :pkgname "ntcmd"
        :description "major mode for editing cmd scripts"
        :load-path "."
        :prepare (progn
                   (add-to-list 'auto-mode-alist '("\\.[bB][Aa][Tt]\\'" . ntcmd-mode))
                   (add-to-list 'auto-mode-alist '("\\.[Cc][Mm][Dd]\\'" . ntcmd-mode))))
      ;; From https://raw.githubusercontent.com/dimitri/el-get/master/recipes/tramp.rcp
      (el-get-bundle tramp
        :description "Transparent Remote Access, Multiple Protocols."
        :website "http://www.gnu.org/s/tramp/"
        :type git
        :url "git://git.savannah.gnu.org/tramp.git"
        :build
        `(("autoconf")
          ("./configure" ,(concat "--with-emacs=" el-get-emacs)
           ,(concat "--prefix="
                    (expand-file-name
                     (el-get-package-directory "tramp"))))
          ("make")
          ("make" "install"))
        :load-path ("./lisp")
        ;; tramp-loaddefs.el uses `tramp-verion' before it's defined,
        ;; work around this by loading trampver.el first.
        :autoloads ("trampver.el" "tramp-loaddefs.el")
        :prepare (progn
                   ;; Helm will try to call this function in order to figure out
                   ;; if tramp will be used.
                   (autoload 'tramp-check-proper-method-and-host "tramp.el"))
        :info "share/info")
      (el-get-bundle org-learn
        :type http
        :pkgname "org-learn"
        :description "org-learn"
        :url "http://orgmode.org/w/?p=org-mode.git;a=blob_plain;f=contrib/lisp/org-learn.el"))
    #+END_SRC

* a-mode

  `a-mode' is (if I remember correctly) my first Emacs Lisp function,
  quite simple really, all it does is act as a wrapper for
  `auto-mode-alist', shortening the overall use of it from:

  #+BEGIN_SRC emacs-lisp :tangle no
    (add-to-list 'auto-mode-alist "\\.markdown\\" 'markdown-mode)
  #+END_SRC

  to:

  #+BEGIN_SRC emacs-lisp :tangle no
    (a-mode "markdown" "markdown-mode")
  #+END_SRC

  which I prefer

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun a-mode (ext mode)
      "A 'shortcut' for `(add-to-list 'auto-mode-alist [...])`'"
      (add-to-list 'auto-mode-alist
                   (cons
                    (format "\\%s\\'" ext)
                    (intern (concat mode "-mode")))))
  #+END_SRC

* Org

  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'ox-twbs)
  #+END_SRC

** Org directory

   =~/org= seems the best place to store such things.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package org
      :config
      (rebind-key (kbd "C-c <left>") org-mode-map (kbd "C-x <left>"))
      (rebind-key (kbd "C-c <right>") org-mode-map (kbd "C-x <right>"))
      (setq org-directory (expand-file-name "~/org/"))
  #+END_SRC

** Key bindings

  #+BEGIN_SRC emacs-lisp :tangle yes
      (define-key global-map (kbd "C-c l") 'org-store-link)
      (define-key global-map (kbd "C-c a") 'org-agenda)
  #+END_SRC

** UTF8 checkboxes

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-html-checkbox-type 'unicode
           org-html-checkbox-types
           '((unicode (on . "<span class=\"task-done\">&#x2611;</span>")
                      (off . "<span class=\"task-todo\">&#x2610;</span>")
                      (trans . "<span class=\"task-in-progress\">[-]</span>"))))
     (defun org-twbs-checkbox (checkbox)
       (case checkbox
             (on "<span class=\"task-done\">&#x2611;</span>")
             (off "<span class=\"task-todo\">&#x2610;</span>")
             (trans "<span class=\"task-in-progress\">[-]</span>")
             (t "")))
   #+END_SRC

** =org-agenda-files=

   Set to =org-directory= since that just makes sense.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'find-lisp)
     (setq org-agenda-files
           (append (find-lisp-find-files "~/org" "\.org$")
                   (find-lisp-find-files "~/MassRevision" "\.org$")))
   #+END_SRC
** =org-log-done=

   As per the documentation, this simply adds a time stamp when I mark a task as DONE.

   #+BEGIN_SRC emacs-lisp :tangle yes
    (setq org-log-done 'time)
   #+END_SRC

** Minted instead of listings

   This enables the [[http://ctan.mirrorcatalogs.com/macros/latex/contrib/minted/minted.pdf][minted]] syntax highlighter when exporting to
   LaTeX. Minted is like listings in LaTeX, but uses [[http://pygments.org/][Pygments]] as the
   backend for generating the syntax highlighting.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-latex-listings 'minted)
   #+END_SRC

*** Options

    - =frame= produces a box around all code blocks.
    - =fontsize \\scriptsize= make the fontsize the same as the rest
      of the document.
    - =linenos= enables line numbers
    - =breakautoindent= when breaking a line that is too long,
      automatically indent the line produced from breaking
    - =breaklines= break lines that are too long

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-latex-minted-options '(("frame" "lines")
                                      ("fontsize" "\\scriptsize")
                                      ("linenos" "")
                                      ("breakautoindent")
                                      ("breaklines")))
   #+END_SRC

   =org-latex-minted-langs= simply aliases Emacs mode names (that
   might not be known by Pygments) to a language Pygments knows.

   - =conf-space=: tmux and udev files

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-latex-minted-langs '((conf-space "aconf")
                                    (conf-unix "squid")
                                    (text "snippet")))
   #+END_SRC
** UTF-8 in XeLaTeX

   #+BEGIN_SRC emacs-lisp :tangle yes
   ()
   #+END_SRC

** Todo states

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-todo-keywords '((sequence "TODO" "IN PROGRESS" "DONE")))
   #+END_SRC

** Import the LaTeX package

   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'org-latex-default-packages-alist '("" "minted" t))
   #+END_SRC

** Highlighting

   Clever way to color text, from [[https://www.mail-archive.com/emacs-orgmode@gnu.org/msg29988.html][here]].

   #+BEGIN_SRC emacs-lisp :tangle yes
     (org-add-link-type
      "color" nil
      (lambda (path desc format)
        (cond
         ((eq format 'html)
          (format "<span style=\"color:%s;\">%s</span>" path desc))
         ((eq format 'latex)
          (format "{\\color{%s}%s}" path desc)))))
     (org-add-link-type
      "hl" nil
      (lambda (path desc format)
        (cond
         ((eq format 'html)
          (format "<font style=\"background-color:%s;\">%s</font>" path desc))
         ((eq format 'latex)
          (format "\\colorbox{%s}{%s}" path desc)))))
   #+END_SRC


** VideoJS

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar vid-format
    (concat "<video class=\"video-js\" controls preload=\"auto\" width=\"640\" height=\"264\""
            "data-setup=\"{}\">"
            "<source src=\"%s\" type='video/webm'>"
            "</video>"))
  (org-add-link-type "webm"
                     (lambda (handle)
                       (browse-url (concat handle)))
                     (lambda (path desc backend)
                       (cl-case backend
                         (html (format vid-format
                                       path (or desc ""))))))
#+END_SRC


** Confirm or not to confirm, that is the question

   (Sorry to any Shakespeare fans)

   I don't need, or want, to press =y= for any document that has a lot
   of Graphviz/PlantUML diagrams.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-org-confirm-babel-evaluate (lang body)
       (not (or (string= lang "dot") ;; don't ask to run a Graphviz block
                (string= lang "gnuplot")
                (string= lang "plantuml")))) ;; don't ask for PlantUML blocks
     (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
     (add-hook 'after-init-hook (lambda ()
                                  (define-key evil-normal-state-map (kbd "TAB") 'org-cycle))) ;; readd TAB back to normal mode in EVIL
   #+END_SRC

** Org-capture + Org-protocol

   Template declarations are in =init.el= so I can use M-x customize-variable RET with it.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'org-capture)
     (require 'org-protocol)
     (require 'org-protocol-capture-html)

     ;; Org Capture
     ;; Thank you random person from StackOverflow
     ;; http://stackoverflow.com/questions/23517372/hook-or-advice-when-aborting-org-capture-before-template-selection

     (defadvice org-capture
         (after make-full-window-frame activate)
       "Advise capture to be the only window when used as a popup"
       (if (equal "emacs-capture" (frame-parameter nil 'name))
           (delete-other-windows)))

     (defadvice org-capture-finalize
         (after delete-capture-frame activate)
       "Advise capture-finalize to close the frame"
       (if (equal "emacs-capture" (frame-parameter nil 'name))
           (delete-frame)))
   #+END_SRC

*** Bookmarklets

**** Link and text

     #+BEGIN_SRC javascript
     javascript:location.href='org-protocol://capture://t/'+encodeURIComponent(location.href)+'/'+encodeURIComponent(document.title)+'/'+encodeURIComponent(window.getSelection())
     #+END_SRC

**** HTML

     #+BEGIN_SRC javascript
     javascript:location.href = 'org-protocol://capture-readability://w/' + encodeURIComponent(location.href) + '/' + encodeURIComponent(document.title) + '/';
     #+END_SRC


**** Link

     #+BEGIN_SRC javascript
     javascript:location.href='org-protocol://capture://L/'+encodeURIComponent(location.href)+'/'+encodeURIComponent(document.title)+'/'+encodeURIComponent(window.getSelection())
     #+END_SRC


** Beautiful Org
*** Org-bullets
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package org-bullets
        :config
        (add-hook 'org-mode-hook 'org-bullets-mode))
    #+END_SRC

*** Org-beautify theme

    #+BEGIN_SRC emacs-lisp :tangle yes
      (load-theme 'org-beautify t)
    #+END_SRC

** Babel

   Load the Babel languages that I use, and also use nifty embedded
   highlighting (syntax within syntax).

   #+BEGIN_SRC emacs-lisp :tangle yes
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((ruby . t)
        (gnuplot . t)
        (org . t)
        (plantuml . t)
        (dot . t)))
     (setq org-src-fontify-natively t)
     (setq org-plantuml-jar-path (expand-file-name "~/plantuml.jar"))
     (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
     (add-to-list 'org-src-lang-modes '("plantuml" . puml))
   #+END_SRC
*** Languages
**** Haskell (diagrams)

     #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ob-diagrams)
     #+END_SRC


** Org-drill

   Used for my flashcards.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'org-drill)
   #+END_SRC

** Clocking

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-clock-persist 'history)
     (org-clock-persistence-insinuate)
   #+END_SRC

** Exporting engine
*** TWBS

    When exporting using =org-twbs= (Twitter Bootstrap for Org mode) I
    would like to include a CSS file generated using =htmlize.el=.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq org-twbs-head (concat org-twbs-head
                                  (with-temp-buffer
                                    (insert-file-contents (expand-file-name "~/.homesick/repos/dotfiles/css.html"))
                                    (buffer-string))))) ;; =.org= note: extra paren since we close the far above =use-package=
    #+END_SRC

*** Reveal.js

    #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ox-reveal)
    #+END_SRC

** Org-ref

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package org-ref)
   #+END_SRC

** revealjs

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-reveal-root "https://xack.xyz/misc/docs/reveal.js")
   #+END_SRC

** auto-fill-mode

   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'org-mode-hook 'turn-on-auto-fill)
   #+END_SRC

* Winner

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package winner)
  #+END_SRC

* PlantUML

    Enable auto-image-file-mode everywhere, otherwise, when using
    `auto-revert-mode` the raw text of the image is displayed after
    reverting

  #+BEGIN_SRC emacs-lisp :tangle yes
    (auto-image-file-mode 1)
    (add-hook 'image-mode-hook 'auto-revert-mode)
  #+END_SRC

* Flycheck

  Flycheck is the "modern equivalent of flymake", think of it as [[https://github.com/scrooloose/syntastic][Syntastic]] but for Emacs.

  It adds:

  - Markers in the fringe where syntax errors/style errors/warnings occur.
  - Adds an underline exactly where the error occurs. Fantastic when using a spell checker.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package flycheck
      :config
      (setq flycheck-check-syntax-automatically '(save mode-enabled)) ;; check when the file is written, or a new mode is enabled.
      (setq flycheck-highlighting-mode 'symbols)
      (add-hook 'after-init-hook 'global-flycheck-mode) ;; enable flycheck globally
      (setq flycheck-indication-mode 'left-fringe)) ;; indicate syntax errors/warnings in the left-fringe.
  #+END_SRC

** pos-tip

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flycheck-pos-tip
       :config
       (flycheck-pos-tip-mode 1))
   #+END_SRC


** Flyspell

   Spell checking for Flycheck.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'prog-mode-hook  'flyspell-prog-mode)
     (add-hook 'text-mode-hook  'flyspell-mode)
     (setq python-shell-interpreter "python3") ;; I use Python 3
   #+END_SRC

** Prose lint

   #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package flycheck-proselint)
   #+END_SRC

** Load-path inheritance

   This makes sure that when requiring a file that's within my `load-path' when editing Emacs Lisp code that Flycheck uses my load-path instead of an internal one.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default flycheck-emacs-lisp-load-path 'inherit)
   #+END_SRC
* Emmet

  [[http:/emmet.io][Emmet]] is an incredibly useful tool when dealing with HTML, think of it as "super-charged snippets for HTML".

** =turn-on-emmet-mode=

   Tiny function to use instead of =(lambda [...])= to DRY the code.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun turn-on-emmet-mode ()
       (emmet-mode 1))
   #+END_SRC

   For =(web|sgml|css)-mode=, turn on emmet-mode.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package emmet-mode
       :config
       (add-hook 'web-mode-hook 'turn-on-emmet-mode)
       (add-hook 'sgml-mode-hook 'turn-on-emmet-mode)
       (add-hook 'css-mode-hook 'turn-on-emmet-mode))
   #+END_SRC

* avy

  =avy= is like VIM's [[https://github.com/Lokaltog/vim-easymotion][EasyMotion]] but for Emacs.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package avy
      :config
      (define-key global-map (kbd "C-c k c") 'avy-goto-char)
      (define-key global-map (kbd "C-c k w") 'avy-goto-word-1)
      (define-key global-map (kbd "C-c k l") 'avy-goto-line))
  #+END_SRC

* Magit
  Magit is fantastic!

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package magit
      :bind (("C-c C-s C-s" . magit-status))
      :config
      (setq magit-auto-revert-mode nil)
      (setq magit-last-seen-setup-instructions "1.4.0"))
  #+END_SRC

* Company

  =Company= is a fantastic alternative to =auto-complete=.

  The following:

  - Enables it globally.
  - Makes the completion window popup almost instantly.
  - Makes the completion window popup even if I type a single character.
  - Unbinds `C-w` when within the completion window to prevent a conflict with =evil-mode=.
  - Rebind the previously unbound =company-show-location= to =C-u=.
  - And finally makes =company-backends= local.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package company
      :config
      (add-hook 'after-init-hook 'global-company-mode) ;; enable company-mode globally
      (setq company-idle-delay 0.1)
      (setq company-minimum-prefix-length 1)
      (unbind-key (kbd "C-w") company-active-map)
      (define-key company-active-map (kbd "C-u") 'company-show-location)
      (make-variable-buffer-local 'company-backends)
       (add-hook 'c-mode-hook (lambda ()
                                      (add-to-list 'company-backends 'company-clang))))
  #+END_SRC

** Anaconda

   Allows for auto-completion with Python and Company.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package company-anaconda
       :config
       (add-hook 'python-mode-hook (lambda ()
                                     (anaconda-mode)
                                     (add-to-list 'company-backends 'company-anaconda))))
   #+END_SRC

** Haskell

   Utilize =ghc= to autocomplete using Company.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package company-ghc
       :config
       (add-hook 'haskell-mode-hook (lambda ()
                                      (add-to-list 'company-backends 'company-ghc)))
       ;; Haskell!
       (autoload 'ghc-init "ghc" nil t))
   #+END_SRC

** Go
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-go
    :config
    (add-hook 'go-mode-hook (lambda ()
                                  (add-to-list 'company-backends 'company-go))))
#+END_SRC
* edit-server

  The Chrom(e|ium) addon [[https://chrome.google.com/webstore/detail/edit-with-emacs/ljobjlafonikaiipfkggjbhkghgicgoh][Edit with Emacs]] requires this.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package edit-server
      :config
      (edit-server-start))
  #+END_SRC

* Eldoc

  +Disable Eldoc because it causes all of Emacs to freeze.+

  Turns out it was Fira-code with the ligature code I found causing
  Emacs to freeze with =Attempted to shape unibyte text=


  #+BEGIN_SRC emacs-lisp :tangle yes
  (global-eldoc-mode 1)
  #+END_SRC

** TODO Report bug to emacs-bugs

  Eldoc causes freezing of Emacs.

* Anzu

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package anzu
      :config
      (global-anzu-mode 1))
  #+END_SRC

* EVIL

  EVIL is VIM within Emacs.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil
      :init
      (setq evil-toggle-key "C-c C-j")
      :config
      (evil-mode 1)
      (evil-set-initial-state 'dired-mode 'emacs)
      (evil-define-key 'normal global-map (kbd "}]") 'emmet-next-edit-point)
      (evil-define-key 'normal global-map (kbd "{[") 'emmet-prev-edit-point)
      (evil-define-key 'normal global-map (kbd "U") 'undo-tree-visualize)
      ;; http://stackoverflow.com/questions/20882935/how-to-move-between-visual-lines-and-move-past-newline-in-evil-mode
      ;; Make movement keys work like they should
      (define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
      (define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
      (define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
      (define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
                                            ; Make horizontal movement cross lines
      (setq-default evil-cross-lines t))
  #+END_SRC

** Text-object delimiters

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package surround
       :config
       (global-surround-mode 1))
   #+END_SRC


** NERD-commenter

   VIM's NERD-commenter but for Emacs.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-nerd-commenter
       :config
       (define-key evil-normal-state-map "gci" 'evilnc-comment-or-uncomment-lines)
       (define-key evil-normal-state-map "gcl" 'evilnc-quick-comment-or-uncomment-to-the-line)
       (define-key evil-normal-state-map "gll" 'evilnc-quick-comment-or-uncomment-to-the-line)
       (define-key evil-normal-state-map "gcc" 'evilnc-copy-and-comment-lines)
       (define-key evil-normal-state-map "gcp" 'evilnc-comment-or-uncomment-paragraphs)
       (define-key evil-normal-state-map "gcr" 'comment-or-uncomment-region)
       (define-key evil-normal-state-map "gcv" 'evilnc-toggle-invert-comment-line-by-line))
   #+END_SRC

** Leader

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-leader
       :config
       (evil-leader/set-leader "<SPC>") ;; space is my leader
       (global-evil-leader-mode 1)
       (evil-leader/set-key
         "p b" 'projectile-switch-to-buffer
         "p D" 'projectile-dired
         "p d" 'projectile-find-dir
         "p s" 'projectile-switch-project
         "p R" 'projectile-regenerate-tags
         "p j" 'projectile-find-tag
         "g t r" 'ctags-create-or-update-tags-table))
   #+END_SRC
** Modeline color changing

   I found this in Bling's dotemacs.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (set-face-background 'mode-line "SaddleBrown")
     (defun my-evil-modeline-change (default-color)
       "changes the modeline color when the evil mode changes"
       (let ((color (cond ((evil-insert-state-p) '("#002233" . "#ffffff"))
                          ((evil-visual-state-p) '("#330022" . "#ffffff"))
                          ((evil-normal-state-p) default-color)
                          (t '("#440000" . "#ffffff")))))
         (set-face-background 'mode-line (car color))
         (set-face-foreground 'mode-line (cdr color))))

     (lexical-let ((default-color (cons (face-background 'mode-line)
                                        (face-foreground 'mode-line))))
       (add-hook 'post-command-hook (lambda () (my-evil-modeline-change default-color))))
   #+END_SRC

** textobj-anyblock

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-textobj-anyblock
       :config
       (define-key evil-inner-text-objects-map "b" 'evil-textobj-anyblock-inner-block)
       (define-key evil-outer-text-objects-map "b" 'evil-textobj-anyblock-a-block))
   #+END_SRC

** Cursor changing

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq evil-insert-state-cursor '((bar . 2) "white")
           evil-visual-state-cursor '((bar . 5) "white")
           evil-normal-state-cursor '((hollow . 5) "white"))
   #+END_SRC

** Matching

   Extends =%=.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-matchit
       :config
       (global-evil-matchit-mode 1))
   #+END_SRC

** Space

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-space
       :config
       (evil-space-mode 1))
   #+END_SRC

* Git-gutter

  Git-gutter displays a summary of =git diff= in the left fringe of the current buffer.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package git-gutter
      :config
      (global-git-gutter-mode 1))
  #+END_SRC

* Dired
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package dired-subtree
      :config
      (bind-keys :map dired-mode-map
                 ("TAB" . dired-subtree-insert)
                 ("<backtab>" . dired-subtree-remove)))
  #+END_SRC
* Helm
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package helm
      :config
      (helm-mode 1)
      (helm-autoresize-mode 1)
      (global-set-key (kbd "C-x C-f") 'helm-find-files)
      (setq helm-mode-fuzzy-match t))
  #+END_SRC
** Projectile
   Integrate Projectile and Helm.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package helm-projectile
       :config
       (global-set-key (kbd "C-c h") 'helm-projectile))
   #+END_SRC

** Helm-M-x

   Helm's version of M-x.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (define-key global-map (kbd "M-x") 'helm-M-x)
   #+END_SRC

** Helm-swoop

   Alternative to I-search.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package helm-swoop
       :config
       (define-key global-map (kbd "C-c C-a C-c") 'helm-swoop))
   #+END_SRC

* Languages
** SCSS

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package scss-mode
       :config
       (setq scss-compile-at-save nil)
       (a-mode ".scss" "scss"))

   #+END_SRC

** Common Lisp
*** SLIME

    SLIME (Superior Lisp Interaction Mode for Emacs) turns Emacs into
    an excellent IDE for Common Lisp.

    The following makes sure that I can still use the SLIME REPL
    history when on-the-go with my physical keyboard and phone.

    =slime-setup= is also loads:

    - slime-fancy: makes SLIME spiffy with history, and other stuff.
    - slime-repl: the core of SLIME
    - slime-company: auto-completion in the REPL when using SLIME.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (require 'slime-autoloads)
      (use-package slime
        :config
        (add-hook 'slime-repl-mode-hook
                  (lambda ()
                    ;; my portable keyboard + VX Connectbot doesn't like M-p and M-n.
                    (evil-define-key 'insert slime-repl-mode-map (kbd "C-p") 'slime-repl-previous-input)
                    (evil-define-key 'insert slime-repl-mode-map (kbd "C-n") 'slime-repl-next-input)
                    (evil-define-key 'normal slime-repl-mode-map (kbd "C-p") 'slime-repl-previous-input)
                    (evil-define-key 'normal slime-repl-mode-map (kbd "C-n") 'slime-repl-next-input)))
        (slime-setup '(slime-fancy slime-repl slime-company))
        (setq inferior-lisp-program "sbcl")) ;; use SBCL
    #+END_SRC


** Haskell

   I don't program in Haskell much, but someday I will.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package haskell-mode
       :config
       (setq haskell-font-lock-symbols t) ;; spiffy symbols.
       (add-hook 'haskell-mode-hook 'ghc-init)
       (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation))
   #+END_SRC


** Cider

   I like Clojure, so CIDER is a must for me.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package cider
       :config
       ;; (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
       (a-mode ".boot" "clojure")
       (add-to-list 'magic-mode-alist '(". boot" . clojure-mode)))
   #+END_SRC

** JavaScript

   I like JavaScript.

   js2-mode is a great alternative to the standard js-mode.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package js2-mode
       :init
       (a-mode ".es6" "js2")
       (a-mode ".js" "js2")
       (add-hook 'js2-mode-hook (lambda ()
                                  (tern-mode t) ;; enable auto-completion using ternjs.
                                  (add-to-list 'company-backends 'company-tern))))
   #+END_SRC

*** Notes

    - js2-mode works great with ES6
    - ternjs doesn't work at all with ES6, but it is in the works.

** Web

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package web-mode
       :config
       (a-mode ".phtml" "web")
       (a-mode ".liquid" "web")
       (a-mode ".hamlet" "web")
       (a-mode ".julius" "web")
       (a-mode ".tpl\\.php" "web")
       (a-mode ".[agj]sp" "web")
       (a-mode ".as[cp]x" "web")
       (a-mode ".erb" "web")
       (a-mode ".mustache" "web")
       (a-mode ".djhtml" "web")
       (a-mode ".ejs" "web")
       (a-mode ".html?" "web")
       (a-mode ".php" "web")

       (setq web-mode-enable-auto-closing t)
       (setq web-mode-enable-auto-pairing t))
   #+END_SRC

** Gitolite

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package gl-conf-mode
       :config
       (setq gdscript-tab-width 2)
       (add-to-list 'auto-mode-alist '("gitolite\\.conf\\'" .
                                       gl-conf-mode)))
   #+END_SRC


** GDScript

   Godot's scripting language.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'gdscript-mode)
   #+END_SRC

   Also enable rainbow things for GDScript.


   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'gdscript-mode-hook 'rainbow-identifiers-mode)
     (add-hook 'gdscript-mode-hook 'rainbow-delimiters-mode)
   #+END_SRC

** CMake

   CMake is a great alternative to autotools/automake. I use it for
   any C/C++ project I work on.

   The following makes =CMakeLists.txt= use =cmake-mode=.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package cmake-mode
       :init
       (add-to-list 'auto-mode-alist
                    '("CMakeLists.txt" . cmake-mode)))
   #+END_SRC

** VisualBasic

   Used for work experience.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (autoload 'visual-basic-mode "visual-basic-mode" "Visual Basic mode." t)
     (a-mode ".vbs" "visual-basic")
   #+END_SRC

** Scheme

   Geiser is great for scheme.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package geiser
       :config
       (add-hook 'scheme-mode-hook (lambda ()
                                     (add-to-list 'company-backends 'geiser-company-backend))))
   #+END_SRC

* ibuffer

  ibuffer is an enhanced version of the standard =buffer-menu=.

** VC

   Integrate ibuffer and vc.el.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ibuffer-vc
       :bind ("C-x C-b" . ibuffer)
       :init
       (require 'ibuffer-vc)
       :config
       (setq ibuffer-formats
             '((mark modified read-only vc-status-mini " "
                     (name 18 18 :left :elide)
                     " "
                     (size 9 -1 :right)
                     " "
                     (mode 16 16 :left :elide)
                     " "
                     (vc-status 16 16 :left)
                     " "
                     filename-and-process)))
       (add-hook 'ibuffer-hook
                 (lambda ()
                   (ibuffer-vc-set-filter-groups-by-vc-root))))
   #+END_SRC

* indent-guide

  Indent-guide adds a fancy line to indicate the current indentation position.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package indent-guide
      :config
      (indent-guide-global-mode 1)) ;; enable globally
  #+END_SRC

* Emojis

  Disabled due to it interfering with something in the past,
  unfortunately I never got around to submitting a bug report.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (global-emojify-mode 0)
  #+END_SRC

* highlight-indentation

  Highlight indentation, a complement to indent-guide.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package highlight-indentation
      :config
      (highlight-indentation-mode 1)) ;; enable globally
  #+END_SRC

* Multiple-Major-Modes

  This package is *fantastic* for things that embed other languages.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package mmm-mode
      :config
      (setq mmm-global-mode 'maybe)
      (mmm-add-classes
       '((markdown-latex
          :submode latex-mode
          :front "\\\\begin" ;; 2 blackslashes because of basedocument requiring 2 because of macro processing.
          :back "\\\\end")
         (markdown-erb
          :submode ruby-mode
          :front "<%"
          :back "%>")
         (markdown-clojure
          :submode clojure-mode
          :front "```clojure"
          :back "```")
         (markdown-ruby
          :submode ruby-mode
          :front "```ruby"
          :back "```")
         (markdown-haskell
          :submode haskell-mode
          :front "```haskell"
          :back "```")
         (markdown-lisp
          :submode common-lisp-mode
          :front "```commonlisp"
          :back "```")
         (shell-json
          :submode javascript-mode
          :front "<<JSON"
          :back "JSON")))
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-latex)
      (mmm-add-mode-ext-class 'markdown-mode "\\.mderb\\'" 'markdown-erb)
      (mmm-add-mode-ext-class 'shell-mode "\\.sh\\'" 'shell-json)
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-clojure)
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-ruby)
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-lisp)
      (mmm-add-mode-ext-class 'markdown-mode "\\.md\\'" 'markdown-haskell))
    (a-mode ".mderb" "markdown")
  #+END_SRC

* Projectile

  Projectile is great for handling large projects.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package projectile
      :disabled t
      :bind ("C-c v f" . helm-projectile-find-file)
      :config
      (setq projectile-completion-system 'helm)
      (projectile-global-mode)
      ;; (add-hook 'projectile-mode-hook 'projectile-rails-on)
)
  #+END_SRC

* Mode-line
** Smart-Mode-Line

  I have yet to get around to making my own mode-line, but Smart-Mode-Line is great, so I don't see why I need to, other than for fun of course.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package smart-mode-line
      :config
      (setq sml/theme 'dark)
      (sml/setup))
  #+END_SRC

** mode-icons

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package mode-icons
    :disabled t
    :config
    (mode-icons-mode))
#+END_SRC

* Ag

  Ag is a super-fast alternative to grep.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ag
      :config
      (define-key ag-mode-map (kbd "k") nil)) ;; stop conflicts with evil
  #+END_SRC

* ws-butler

  Used to remove whitespace.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ws-butler
      :config
      (add-hook 'prog-mode-hook 'ws-butler-mode))
  #+END_SRC

* YASnippet

  Snippet for Emacs.


  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yasnippet
      :config
      (yas-global-mode 1)
      (a-mode ".snip" "snippet")
      (define-key yas-minor-mode-map (kbd "C-c 7 n") 'yas-next-field)
      (define-key yas-minor-mode-map (kbd "C-c 7 p") 'yas-prev-field)
      (define-key yas-minor-mode-map (kbd "<tab>") nil)
      (define-key yas-minor-mode-map (kbd "TAB") nil)
      (define-key zack-keys-minor-mode-map (kbd "C-c RET") 'yas-expand))
  #+END_SRC

* Misc keybindings
** =kill-this-buffer=

   #+BEGIN_SRC emacs-lisp :tangle yes
     (define-key zack-keys-minor-mode-map (kbd "C-x C-;") 'kill-this-buffer)
   #+END_SRC
* Email

  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'mail-mode-hook 'auto-fill-mode) ;; hard-wrap text when emailing
  #+END_SRC

** Wanderlust

   Not used much, but might switch to Wanderlust one day.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package wl
       :config
       (autoload 'wl "wl" "Wanderlust" t)
       (a-mode ".wl" "emacs-lisp")
       (add-to-list 'auto-mode-alist
                    '("mutt-" . mail-mode)) ;; mutt temporary files
       (defun wl-evil ()
         (when evil-mode (evil-change-state 'emacs)))

       (add-hook 'wl-hook 'wl-evil)
       (add-hook 'wl-folder-mode-hook 'wl-evil)
       (add-hook 'wl-summary-mode-hook 'wl-evil)
       (add-hook 'wl-message-mode-hook 'wl-evil)
       (add-hook 'mime-view-mode-hook 'wl-evil)
       (add-hook 'wl-template-mode-hook 'wl-evil)
       (add-hook 'mail-citation-hook 'sc-cite-original))
   #+END_SRC
*** Disable message splitting on big attachments

    Thanks to lack of the below code I managed to send 55 emails at one
    time... while complaining about an abusive IP address.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mime-edit-split-message nil)
   #+END_SRC

* Undo-Tree

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package undo-tree
      :config
      (setq undo-tree-auto-save-history 1)
      (setq undo-tree-history-directory-alist (quote (("." . "~/.emacs.d/undo/"))))
      (setq undo-tree-visualizer-diff t))
  #+END_SRC

* Rainbows
** Numbers

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package highlight-numbers
      :config
      (add-hook 'prog-mode-hook 'highlight-numbers-mode))
  #+END_SRC

** Identifiers

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package rainbow-identifiers
      :config
      (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
  #+END_SRC

** Delimiters

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package rainbow-delimiters
      :config
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode-enable)
      (add-hook 'text-mode-hook 'rainbow-delimiters-mode-enable))
  #+END_SRC

* Imenu

  Useful for navigating around my config.

  I got the following from somewhere but I can't remember where from.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package imenu
      :config
      (add-to-list 'imenu-generic-expression
                   '("Used Packages"
                     "\\(^\\s-*(use-package +\\)\\(\\_<.+\\_>\\)" 2))
      (define-key zack-keys-minor-mode-map (kbd "C-x l") 'imenu))
  #+END_SRC

* Browser

Change default browser used in Emacs to Chromium.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program "chrome")
    ;; I compile Chromium myself, and the binary is called "chrome"
  #+END_SRC

* Misc

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq echo-keystrokes 0.01)
    (setq org-export-htmlize-output-type 'css)
    (set-face-attribute 'default nil :height 85)
    (require 'tramp) ;; edit files on remote locations
    (require 'whitespace) ;; whitespace monitor
    (column-number-mode 1) ;; enable column number in modeline
    (menu-bar-mode -1) ;; disabe menubar
    (tool-bar-mode -1) ;; disable toolbar
    (when (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1)) ;; disable scrollbar
    (electric-pair-mode 1) ;; match parens automatically
    (setq-default indent-tabs-mode nil) ;; no tabs.
    (setq-default tab-width 2) ;; Ruby-style indentation
    (require 'saveplace)
    (setq-default save-place t)
    (a-mode ".md" "markdown")
    (a-mode ".slidemd" "markdown")
    (a-mode ".markdown" "markdown")
    (a-mode ".mdwn" "markdown")
    (a-mode "Gemfile" "ruby")
    (a-mode "Guardfile" "ruby")
    (a-mode "Rakefile" "ruby")
    (require 'htmlize)
    (electric-indent-mode 1) ;; automatically indent on RET or others
    (show-paren-mode 1) ;; highlight matching parens
    (mouse-avoidance-mode 'banish) ;; be gone cursor!
    (setq initial-scratch-message ;; I know it's a scratch buffer by now!
          (format ";; Emacs was started at %s"
                  (format-time-string "%Y-%m-%dT%T")))
    (setq package-menu-async nil)
    ;; disable this, I hate it when I
    ;; press "U" just when I run `list-packages' to result in it claiming
    ;; there's no updates avaialble so I have to run it again.
  #+END_SRC

** Backups

   I don't commit on every change I make, that'd be silly, so put
   numbered backups in here to not pollute commit history and
   directory listings.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
     (setq delete-old-versions -1)
     (setq version-control t)
     (setq vc-make-backup-files t)
     (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
   #+END_SRC

* Sort sexps
  From Sacha Chua.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun sort-sexps-in-region (beg end)
      "Can be handy for sorting out duplicates.
        Sorts the sexps from BEG to END. Leaves the point at where it
        couldn't figure things out (ex: syntax errors)."
      (interactive "r")
      (let ((input (buffer-substring beg end))
            list last-point form result)
        (save-restriction
          (save-excursion
            (narrow-to-region beg end)
            (goto-char (point-min))
            (setq last-point (point-min))
            (setq form t)
            (while (and form (not (eobp)))
              (setq form (ignore-errors (read (current-buffer))))
              (when form
                (add-to-list 'list
                             (cons
                              (prin1-to-string form)
                              (buffer-substring last-point (point))))
                (setq last-point (point))))
            (setq list (sort list (lambda (a b) (string< (car a) (car b)))))
            (delete-region (point-min) (point))
            (insert (mapconcat 'cdr list "\n"))))))
  #+END_SRC
** Get a random item from a list

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun get-rnd-list (lst)
       "Get a random item from a list."
       (nth (random* (length lst)) lst))
   #+END_SRC

** Get a random color

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun random-color ()
       "Get a random color."
       (get-rnd-list '("blue" "red" "yellow" "pink")))
   #+END_SRC
*** TODO [0/1]
    - [ ] Add more colors


** Increment the number at point, like VIM's =C-a=

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun increment-number-at-point ()
       (interactive)
       (skip-chars-backward "0123456789")
       (or (looking-at "[0123456789]+")
           (error "No number at point"))
       (replace-match (number-to-string (1+ (string-to-number (match-string 0))))))
     (global-set-key (kbd "C-c +") 'increment-number-at-point)
   #+END_SRC

** Decrement the number at point, like VIM's =C-x=

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun decrement-number-at-point ()
       (interactive)
       (skip-chars-backward "0123456789")
       (or (looking-at "[0123456789]+")
           (error "No number at point"))
       (replace-match (number-to-string (1- (string-to-number (match-string 0))))))

     (global-set-key (kbd "C-c -") 'decrement-number-at-point)

   #+END_SRC

* Boxquote

  From https://github.com/joedicastro/dotfiles/tree/master/emacs

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package boxquote
      :config
      (setq-default  boxquote-bottom-corner ""       ; U+2570
                     boxquote-side          " "      ; U+2572 + space
                     boxquote-top-and-tail  ""    ; U+2500 (4)
                     boxquote-top-corner    ""))     ; U+256F
  #+END_SRC

* Insert shell command

  Insert the output of a shell command into the buffer at cursor's position.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun insert-shell-command (command)
      (interactive "scommand: ")
      (insert (shell-command-to-string command)))

    (define-key global-map (kbd "C-c C-g") 'insert-shell-command)
  #+END_SRC

* History

  - Save an insane amount of previously-used commands.
  - =savehist-file= specifies where to save the variables.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq list-command-history-max 500)
    (setq savehist-file "~/.emacs.d/savehist")
    (savehist-mode 1)
    (setq history-length t)
    (setq history-delete-duplicates t)
    (setq savehist-save-minibuffer-history 1)
    (setq savehist-additional-variables
          '(kill-ring
            search-ring
            regexp-search-ring
            evil-ex-history))
  #+END_SRC

* Extra-warning face

  Used to make things stand out even more then =font-lock-warning-face=.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defface extra-warning-face
      '((t :background "red"
           :foreground "brightblue"))
      "Face for even more warninger warnings."
      :group 'basic-faces)

    (defvar keywords '(("\\b\\(BUG\\)\\b" 1 'extra-warning-face))
      "List of keywords to highlight in extra-warning-face.")

    (add-hook 'prog-mode-hook (lambda () (font-lock-add-keywords nil keywords)))
    (add-hook 'text-mode-hook (lambda () (font-lock-add-keywords nil keywords)))
  #+END_SRC

* Misc utilities

  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'calendar)
    (defun insdate-insert-current-date (&optional omit-day-of-week-p)
      "Insert today's date using the current locale.
    With a prefix argument, the date is inserted without the day of
    the week."
      (interactive "P*")
      (insert (calendar-date-string (calendar-current-date) nil
                                    omit-day-of-week-p)))
  #+END_SRC

* Override keymap

  Idea from http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs

  This is used to override package keymaps (who put there mappings in =C-c=!) without going through the process of:

  1. =C-h k= to see if the binding is used.
  2. Look at =C-h k= to find the keymap it uses.
  3. Unbind the key from the keymap.
  4. Repeat 1 to 3 if packages actually use the same keymapping and they overlap.
  5. Bind your key.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (define-minor-mode zack-keys-minor-mode
      "Override package keys."
      t " z-keys" 'zack-keys-minor-mode-map)
  #+END_SRC

* Tiny

  [[https://github.com/abo-abo/tiny][Tiny]] is an alternative to macros, using a tiny template language.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package tiny
      :config
      (define-key zack-keys-minor-mode-map (kbd "C-j") 'tiny-expand)
      (tiny-setup-default))
  #+END_SRC

* Pinentry

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package pinentry
      :config
      (setenv "INSIDE_EMACS" "1"))
  #+END_SRC

* Pretty symbols
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq prettify-symbols-alist '(("!=" "")
                                   ("! " "")))
  #+END_SRC

* Hydras

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra window-resize (:color blue)

    "
  Resizing
  ========

  _h_: left      _k_: up
  _l_: right     _j_: down"

    ("h" shrink-window-horizontally)
    ("k" shrink-window-horizontally)
    ("l" shrink-window-horizontally)
    ("j" shrink-window-horizontally))
#+END_SRC

* BPR

Background Process Runner.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bpr
    :config
    (setq bpr-colorize-output t))
#+END_SRC

* Font

  From https://github.com/tonsky/FiraCode/wiki/Setting-up-Emacs

  Disabled due to the error "Attempted to shape unibyte text", which ended up breaking some seemingly unrelated things, such as =?= in Ediff's control panel?

#+BEGIN_SRC emacs-lisp :tangle no
  (scase (getenv "HOST")
         ("xieshaij" (set-default-font "Fira Code-8"))
         ("linux-m03e" (set-default-font "Fira Code-8")))

  (let ((alist '((33 . ".\\(?:\\(?:==\\)\\|[!=]\\)")
                 (35 . ".\\(?:[(?[_{]\\)")
                 (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
                 (42 . ".\\(?:\\(?:\\*\\*\\)\\|[*/]\\)")
                 (43 . ".\\(?:\\(?:\\+\\+\\)\\|\\+\\)")
                 (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
                 (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=]\\)")
                 (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
                 (58 . ".\\(?:[:=]\\)")
                 (59 . ".\\(?:;\\)")
                 (60 . ".\\(?:\\(?:!--\\)\\|\\(?:\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[/<=>|-]\\)")
                 (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
                 (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
                 (63 . ".\\(?:[:=?]\\)")
                 (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
                 (94 . ".\\(?:=\\)")
                 (123 . ".\\(?:-\\)")
                 (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
                 (126 . ".\\(?:[=@~-]\\)"))))

    (dolist (char-regexp alist)
      (set-char-table-range composition-function-table (car char-regexp)
                            `([,(cdr char-regexp) 0 font-shape-gstring]))))
#+END_SRC

* Calc

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package calc-ext
    :config
    (define-key calc-mode-map "lr" 'calc-reset))
  (use-package calc
    :config
    (define-key calc-mode-map "lp" 'calc-pop))
#+END_SRC

* BBDB

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bbdb
    :init
    (setq bbdb-file "~/org/bbdb")
    :config
    (bbdb-initialize))
#+END_SRC

* which-key

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package which-key
      :config
      (which-key-mode 1)
      (setq which-key-idle-delay 0.3))
  #+END_SRC

* Beacon

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package beacon
    :config
    (beacon-mode 1))
#+END_SRC

* Batch indentation

  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun indent-buffer ()
      "Format the entire buffer."
      (indent-region (point-min) (point-max) nil)
      (untabify (point-min) (point-max))
      (save-buffer))
    #+END_SRC

* Unicode

  #+BEGIN_SRC emacs-lisp :tangle yes
    (set-language-environment "UTF-8")
    (set-default-coding-systems 'utf-8)
  #+END_SRC

* Prose
** Marking
*** Determine arrow type for marking
    When I'm marking a piece of school work I use a custom made snippet
    for my own notation of correction. The function below is used
    within said snippet in order to not make the snippet incredibly
    long.

    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun z-determine-arrow (text)
        (scase text
               ("" "-->")
               ("" "==>")
               ("N/A" "~~>")))
    #+END_SRC

*** Snippet

    #+BEGIN_SRC snippet :tangle ~/.emacs.d/snippets/markdown-mode/answer.snip
      # name: answer
      # key: answer
      # --
      { ${1:$$(yas-choose-value '("" "" "N/A"))} ${2:$$(z-determine-arrow (yas-field-value 1))} ${3:[N/A]} ;; ${4:Comment} --> [$5/$6] }
    #+END_SRC

*** Haskell parser

    The following is a (very WIP) parser for my "Marking Markup" I created.

    It's WIP because:

    - It gives no AST yet.
    - My Haskell is very beginner-like, so there might be places it could be tidied up.

    #+BEGIN_SRC haskell :tangle ~/bin/m.hs
      import Text.ParserCombinators.Parsec

      determineArrow "" = "-->"
      determineArrow "" = "==>"
      determineArrow "N/A" = "~~>"
      determineArrow x = x ++ " NOT VALID"

      p = do
        string "{ "
        indicator <- string ""
                    <|> string ""
                    <|> string "N/A"
        space
        arrow <- string $ determineArrow indicator
        correctAnswer <- manyTill anyChar (try (string ";;"))
        comment <- manyTill anyChar (lookAhead (try (string "-->")))
        string "--> " -- wasn't consumed because of `lookAhead'
        char '['
        markObtained <- digit
        char '/'
        markOutOf <- digit
        char ']'
        string " }"

      main =
        do
          input <- getContents
          case parse p "(unknown)" input of
                      Left e -> do putStrLn "Error parsing input:"; print e
                      Right r -> mapM_ print r
    #+END_SRC


**** TODO Make it return AST.
**** TODO Tidy up code (where?)
**** TODO Make it more robust
**** TODO Design and write Pandoc filter.

** Typographic mode

   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package typo
       :config
       (defun enable-typo-mode ()
         (typo-mode 1)
         (typo-change-language "English"))
       (add-hook 'org-mode-hook 'enable-typo-mode)
       (add-hook 'wl-draft-mode-hook 'enable-typo-mode)
       (add-hook 'markdown-mode-hook 'enable-typo-mode))
   #+END_SRC

* Keys

  #+BEGIN_SRC emacs-lisp :tangle yes
    (bind-keys :map zack-keys-minor-mode-map
               ("C-x f" . fill-region)
               ("C-x c" . calc))
  #+END_SRC

* The end

  #+BEGIN_SRC emacs-lisp :tangle yes
    (provide 'init) ;; that's a wrap folks!
    ;;; init.el ends here
  #+END_SRC

* Cascade startup system

  This is the remnants of my mini init-system for Emacs, which
  enabled me to easily have multiple Emacs server start
  automatically. That was until I discovered each buffer has its own
  working directory, which made this pointless.

  It is kept here for historical reasons.

** =waitforemacs=

   Hangs until a certain other Emacs server starts.

   #+INCLUDE: "~/bin/waitforemacs" src shell

** =emacsinotify=

   #+INCLUDE: "~/bin/emacsinotify" src shell
